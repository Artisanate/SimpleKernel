# SimpleKernel 开发日志 20200306

想了一下还是把初始栈的位置明确写出来吧。。不然实在很麻烦



# SimpleKernel 开发日志 20200307

将 bootinit 处的栈切换函数移动到 cpu.hpp，改为 void cpu_switch_stack(ptr_t stack_top)

内核栈现在位于 0xBFFF8000-0xC0000000，即内核开始前的 32KB。

下一步是为初始进程添加控制信息

完成了除 pt_regs 的分配，pt_regs 要放在栈底，需要重新算一下

问题：读了几份源码，发现初始进程的 p t_regs 似乎不是必要的，探究一下原因想想怎么写





# SimpleKernel 开发日志 20200309

发现 bug：在汇编里面调用 print-stack 传参数的时候忘了 pop 了，已修复

- 分配栈的时候没有对齐，导致 get_current_task() 无法正常工作，添加一个可以置顶对齐大小的 kmalloc 解决

    要把 slab 分配算法改一下，预计是 while 之后的得大改，下午继续

- 修改了几个内存分配的相关函数

- 添加了 slab.c: find_entry(size_t) 函数，用于寻找合适的内存块



# SimpleKernel 开发日志 20200310

在 slab.c 中添加新的函数 alloc_page(ptr_t va, size_t page)，申请内存页

添加 set_used，set_unused 用于设置内存头与管理结构信息



# SimpleKernel 开发日志 20200312

思考了一下发现，为啥我不直接用 pmm_alloc 进行分配？有物理地址对齐需求的也就只有这里了，用 pmm 刚好啊。

我真傻，真的。我要对齐的是线性地址，关物理内存什么事？我是个沙雕吧

好的，那么新的解决方案是这样：

- 添加一个专门分配栈空间的函数，负责申请物理内存+映射，保证返回的地址可以用 slab 管理
- 为了避免线性空间冲突的问题，需要在每次映射页之前判断一下有没有冲突，旧有的 alloc_page 函数与新的函数都需要

alloc_page 基本完成



# SimpleKernel 开发日志 20200406

好久没有更新，先回顾一下进度：为了配合 `task_pcb_t * get_current_task(void)` 函数，需要实现分配对齐到指定粒度的内存申请函数，目前的解决方案是在 vmm 里添加这个函数，现在要解决的问题是从理论上证明它可以与其它内存分配函数和谐共存。

- 将内核栈大小调整为 8KB
- 删除之前写的内核栈分配函数

- 编写一系列 task 的调试函数
- 添加 `void show_pt_regs(pt_regs_t * pt_regs)` 函数

- 添加设置进程名称的函数 `set_task_name`



# SimpleKernel 开发日志 20200407

完成 task 测试，在 .gitignore 文件中添加 ctag 文件

删除多余 branches

更新 README

合并到 TODO

添加简单的同步功能

移除不必要的锁



# SimpleKernel 开发日志 20200408

之前对 task 部分的测试不完善，应当测试的还有进程退出、切换

有关[中断栈的问题](http://blog.chinaunix.net/uid-23769728-id-3077874.html)

有关[linux进程](https://www.cnblogs.com/arnoldlu/p/8466928.html)

新的问题：初始进程的 pt_regs 需不需要保存，保存在哪里？



# SimpleKernel 开发日志 20200413

准备把初始任务的 esp-sizeof(pt_regs)

这里应该有改进空间

do_exit 结束后应该手动进行任务切换

成功跑通两个三个线程的切换

下一步解决 get_current 获取不到正确地址的问题

# SimpleKernel 开发日志 20200416

获取不到正确地址是因为分配的时候没有严格按照对齐来，导致 esp&0xFFFFE000 结果错误

直接调用 pmm 相关函数来写栈的分配可以避免 slab 的复杂问题。

现有的 slab 实现有很大问题，需要改进

bug 是因为 slab 中的 alloc_stack 函数的初始地址与后面的地址冲突了，数据被覆盖，现在增加了 0x2000 的偏移，成功解决

新的 bug：alloc_stack 的 while 循环没有正常工作，观察到它连续两次分配了相同的地址

定位到 map 函数上，map 的时候没有给页表分配空间。。。

好吧，现在问题成了 vmm 的大问题了，早知道先写测试了。。。md



# SimpleKernel 开发日志 20200417

之前的 map 函数没有给 pte 分配空间，导致实际上写的是 0xC0000000 处的内存，即 VMM_PA_LA(0) 的结果



# SimpleKernel 开发日志 20200421

问题：物理页分配的空间应该是已经映射过的（对于内核页表来说）

引入 ZONE 机制可以解决这个问题

参考资料：https://www.cnblogs.com/wuchanming/p/4756911.html

准备重写 pmm 部分，完成后内存布局如下图

内核物理地址

![截屏2020-04-21 下午7.41.06](https://tva1.sinaimg.cn/large/007S8ZIlly1ge1miy6ncpj30u0134dhd.jpg)



内核虚拟地址：

![截屏2020-04-21 下午7.41.20](https://tva1.sinaimg.cn/large/007S8ZIlly1ge1min8wpgj30uy0u04kd.jpg)





# SimpleKernel 开发日志 20200422

解决从 mulitboot 读取 mmap 信息时的 bug